# <center>动态规划

## 八皇后问题
**题目要求：**
在一个nxn的棋盘上放置n个棋子，使得每行每列和每条对角线上都只有一个棋子，求其摆放的方法数。
给定一个int n，请返回方法数，保证n小于等于15

**思路分析：**
利用一维数组来存储数据，以索引代表行数，以对应的value值代表列数，大大节省空间
利用dfs递归回溯，边判断边累计合适方案数
判断的要求是当前皇后是否与之前的皇后在同一行，同一列，同一对角线，如果是则此方案不通，继续换另一种方案。

**代码实现：**
```cpp
class Queens {
public:
    int nQueens(int n) {
        int count=0;//记录方案数
        int *a=new int[n+1];
        dfs(a,1,n,count);
        return count;
    }
    int place(int *a,int i){//判断此位置放皇后是否合适，即与前面几个皇后是否相撞
		for(int k=1;k<i;k++){//k表示行，遍历的范围是放这个i皇后之前的所有行
			if((a[i]==a[k])||(a[i]-a[k]==(i-k))||(a[i]-a[k]==k-i)){
				return 0;
				//剪枝，即判断是否符合条件来放,i表示皇后所在的行数，a[i]表示所在的列数，
	            //所以后面条件用来判断两个皇后是否在对角线上,前面用来判断是否在同一列上。
	            //行数不需要判断，因为他们本身的i就代表的是行数
			}
		}
		return 1;//说明此位置可以放第i个皇后，返回1
	} 
    void dfs(int a[],int i,int n,int &count){
		if(i>n){//递归截止条件：皇后数i大于所给的n
			count++;//记录下一种方案加1
			return ;
		}
		for(int k=1;k<=n;k++){
			a[i]=k;//第i个皇后放的列数
			if(place(a,i)){
				dfs(a,i+1,n,count);
			}
		}
	}
};
```
**运行结果：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413214244426.png)
